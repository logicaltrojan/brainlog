
### How plain JDBC Transaction Management Works
How to start, commit or rollback JDBC transactions

```java
import java.sql.Connection;

Connection connection = dataSource.getConnection(); // (1)

try (connection) {
    connection.setAutoCommit(false); // (2)
    // execute some SQL statements...
    connection.commit(); // (3)

} catch (SQLException e) {
    connection.rollback(); // (4)
}
```
1) Get a connection to a DB (보통 db커넥션 풀이 관리된다.)
2) This is the only way to start a db transaction in Java, setting auto commit false, getting control of transactions
3) commit our transaction
4) or rollback changes

How to use JDBC Isolation levels and savepoints

This is how Spring(or boot) configures the isolation level and propogation

```java
import java.sql.Connection;

// isolation=TransactionDefinition.ISOLATION_READ_UNCOMMITTED

connection.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED); // (1)

// propagation=TransactionDefinition.NESTED

Savepoint savePoint = connection.setSavepoint(); // (2)
...
connection.rollback(savePoint);
```

### How Spring / Spring Boot's transaction Management works

Spring/Boots transaction management : Simple Question , How does Spring start, commit or rollback JDBC transactions? 


How to use Spring's Programaatic Transaction Management? 

```java
@Service
public class UserService {

    @Autowired
    private TransactionTemplate template;

    public Long registerUser(User user) {
        Long id = template.execute(status ->  {
            // execute some SQL that e.g.
            // inserts the user into the db and returns the autogenerated id
            return id;
        });
    }
}
```

위의 jdbc example과 비교해서 
1. do not mess with opening or closing db connections by myself
2. do not catch SQL exceptions, spring converts these exceptions to runtime exception
3. TransactionTemplate will use TransactionManager, whic will use DataSource



How to use Spring's @Transactional annotation (Declarative Transaction Management) 
```java
public class UserService {

    @Transactional
    public Long registerUser(User user) {
       // execute some SQL that e.g.
        // inserts the user into the db and retrieves the autogenerated id
        // userDao.save(user);
        return id;
    }
}
```
1. Make sure Spring configuration is annotated with the @EnableTransactionManagement annotation (In Spring boot default configured) 
2. Make sure you specify transaction manager in your Spring counfiguration


CGlib & JDK Proxies - @Transactional under the covers

Spring cannot rewrite Java class, how Spring can inject transaction code? 

Spring use IOC container, so Spring can give ProxyBean.

![IMAGE](https://www.marcobehler.com/images/document1.png)

The proxy bean has one job : Open db connection(tx connection), delegate to real method, close tx 



For what do you need a Transaction Manager (like PlatformTransactionManager)?

ProxyBean does not handles Transaction itself. ProxyBean delegates transaction managements to a transaction manager.

Spring offers 
1. PlatformTransactionManager interface
2. TransactionManager interface

-> comes with hany implementations, (DataSoruceTranactionManager) 

```java
@Bean
public DataSource dataSource() {
    return new MysqlDataSource(); // (1)
}

@Bean
public PlatformTransactionManager txManager() {
    return new DataSourceTransactionManager(dataSource()); // (2)
}

```
1) Create db specific or connection-pool specific datasource
2) Create transaction manager, which needs a a datasource to be able to manage transactions

Transaction manager usese exactly the same code as JDBC connection handling.

```java
public class DataSourceTransactionManager implements PlatformTransactionManager {

    @Override
    protected void doBegin(Object transaction, TransactionDefinition definition) {
        Connection newCon = obtainDataSource().getConnection();
        // ...
        con.setAutoCommit(false);
        // yes, that's it!
    }

    @Override
    protected void doCommit(DefaultTransactionStatus status) {
        // ...
        Connection connection = status.getTransaction().getConnectionHolder().getConnection();
        try {
            con.commit();
        } catch (SQLException ex) {
            throw new TransactionSystemException("Could not commit JDBC transaction", ex);
        }
    }
}

```
<image src=https://www.marcobehler.com/images/document2.png>


Sum up 
1. If Spring detects the @Transactional annotatio on a bean, it creates a dynamic proxy of that bean
2. The proxy has access to a transaction manager and will ask it to open and close transactions and connections
3. The transacton manager itself will simply do what you did in plain Java : Manage good, old JDBC connection




What is the difference between physical and logical transactions?

```java
@Service
public class UserService {

    @Autowired
    private InvoiceService invoiceService;

    @Transactional
    public void invoice() {
        invoiceService.createPdf();
        // send invoice as email, etc.
    }
}

@Service
public class InvoiceService {

    @Transactional
    public void createPdf() {
        // ...
    }
}
```

In Database : One Transaction (getConnection(), setAutoCommit(false), commit())
In Spring : Two Transaction (First UserService, Second InvoiceService, but in same DB transaction) 


```java
@Service
public class InvoiceService {

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    // tells Spring that this method needs to execute in its own transaction, indepenedent of any other, already existing transaction.
    public void createPdf() {
        // ...
    }
}
```

this code will open two(physical) connections/transactions to the database 
(getConnection()*2, setAutoCommit(false) * 2 , commit() * 2) 

so this has two physical transaction, mapped with two logical transaction.

Physical Transaction : Actual JDBC transaction
Logical Transaction : (Potentially nested) @Transactional-annotated methods


What are @Transactional Propagation Levels used for?

- REQUIRED
- SUPPORTS
- MANDATORY
- REQUIRES_NEW
- NOT_SUPPORTED
- NEVER
- NESTED


Required (default): My method needs a transaction, either open one for me or use an existing one → getConnection(). setAutocommit(false). commit().
 이미 진행중인 트랜잭션이 있다면 해당 트랜잭션 속성을 따르고, 진행중이 아니라면 새로운 트랜잭션을 생성한다.

Supports: I don’t really care if a transaction is open or not, i can work either way → nothing to do with JDBC
 이미 진행 중인 트랜잭션이 있다면 해당 트랜잭션 속성을 따르고, 없다면 트랜잭션을 설정하지 않는다.

Mandatory: I’m not going to open up a transaction myself, but I’m going to cry if no one else opened one up → nothing to do with JDBC
 이미 진행중인 트랜잭션이 있어야만, 작업을 수행한다. 없다면 Exception을 발생시킨다.

Require_new: I want my completely own transaction → getConnection(). setAutocommit(false). commit().
 항생 새로운 트랜잭션을 생성한다. 이미 진행중인 트랜잭션이 있다면 잠깐 보류하고 해당 트랜잭션 작업을 먼저 진행한다

Not_Supported: I really don’t like transactions, I will even try and suspend a current, running transaction → nothing to do with JDBC
 이미 진행중인 트랜잭션이 있다면 보류하고, 트랜잭션 없이 작업을 수행한다.

Never: I’m going to cry if someone else started up a transaction → nothing to do with JDBC
트랜잭션이 진행중이지 않을 때 작업을 수행한다. 트랜잭션이 있다면 Exception을 발생시킨다.

Nested: It sounds so complicated, but we are just talking savepoints! → connection.setSavepoint()
진행중인 트랜잭션이 있다면 중첩된 트랜잭션이 실행되며, 존재하지 않으면 REQUIRED와 동일하게 실행된다.


The most common @Transactional pitfall
```java
@Service
public class UserService {

    @Transactional
    public void invoice() {
        createPdf();
        // send invoice as email, etc.
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void createPdf() {
        // ...
    }
}
```

This opens up just one transaction(physical) => beacuse its proxy bean 
<img src=https://www.marcobehler.com/images/document3.png>

always keep the proxy transaction boundaries in mind


### How Spring and JPA / Hibernate Transaction works




